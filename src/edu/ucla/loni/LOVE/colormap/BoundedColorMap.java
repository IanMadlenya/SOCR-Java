// 	$Id: BoundedColorMap.java,v 1.1 2010/03/10 20:35:29 jiecui Exp $
package edu.ucla.loni.LOVE.colormap;

import edu.ucla.loni.LOVE.BoundedModelImpl;
import edu.ucla.loni.LOVE.PluginLoader;

import java.awt.*;
import java.awt.image.ColorModel;
import java.util.*;
import java.util.List;
/**
 * This is a bounded colormap. Any changes to this
 * colormap will fire a <code>PropertyChangeEvent</code> to
 * the listeners that are registered.
 *
 * This class will create a actual colormap class based on the
 * user's choice, and delegate all the request of colormap changes
 * to this colormap instance and send a changevent as well.
 * It will return the colormap generated by this colormap.
 *
 * The affected properties may include:
 * upper limit, lower limit, under color, over color, alpha,
 * colormap's style
 *
 * A special notice on colormap plugin could be found at: ???
 */
public class BoundedColorMap extends BoundedModelImpl
{
    /** The colormaps in plugin directory. */
    private static Hashtable _colorMapClasses;
    /** Name of the colormaps in plugin directory. */
    private static Object[] _colorMapNames;

    static {
        //load colormap plugins when class are loaded
        _colorMapClasses = PluginLoader
                .loadDirectory("edu.ucla.loni.LOVE.colormap.plugins");

        //sort the keys
        List l = Arrays.asList(_colorMapClasses.keySet().toArray());
        Collections.sort(l);

        _colorMapNames = l.toArray();
        //Fotis
        //System.out.println("BoundedColorMap::Colormaps: " + l);
    }

	/**
	 * The colormap instance managed by this class.
	 *
	 * @uml.property name="_colorMap"
	 * @uml.associationEnd multiplicity="(0 1)"
	 */
	private ColorMap _colorMap;

	//basic information of the bounded model

	/**
	 * The size of the colormap
	 *
	 * @uml.property name="_size"
	 */
	private int _size;

	/**
	 * Bits used per pixel
	 *
	 * @uml.property name="_bits"
	 */
	private int _bits;

	/**
	 * Is inverted?
	 *
	 * @uml.property name="_isInverted"
	 */
	private boolean _isInverted;

	/**
	 * Current class name.
	 *
	 * @uml.property name="_currentColorMapName"
	 */
	private Object _currentColorMapName;



    /**
     *
     * /**
     * Constructor.
     *
     * @param size  Size of the colormap.
     * @param bits  Bits each pixel.
     */
    public BoundedColorMap(int size, int bits) {
        //make default choice to colormap 0
        this(size, bits, 0);
    }

    /**
     * Constructor with default initial choice at index n.
     *
     * @param size  Size of the colormap.
     * @param bits  Bits each pixel.
     * @param n  Index of the intial colormap.
     */
    public BoundedColorMap(int size, int bits, int n) {
        _size = size;
        _bits = bits;
        setColorMapName(_colorMapNames[n]);
    }

	/**
	 * Get number of bits for this colormap. This information
	 * is not supposed to be changed after initialization. So,
	 * there is no set method.
	 *
	 * @return Number of bits for this colormap.
	 *
	 * @uml.property name="_bits"
	 */
	public int getBits() {
		return _bits;
	}

	/**
	 * Get size of this colormap. This information
	 * is not supposed to be changed after initialization.
	 * So, there is no set method.
	 *
	 * @return Size of the colormap.
	 *
	 * @uml.property name="_size"
	 */
	public int getSize() {
		return _size;
	}


    /**
     * Copy the settings from another colormap.
     * Here we need to do something smart, if the bits
     * is not the same, we won't copy upper and lower limit.
     *
     * @param cMap  The colormap to be copied into this.
     */
    public void copyColorMap(BoundedColorMap cMap) {
        //1. check for bits
        if(cMap.getSize() == getSize()) {
            //copy limits
            setUpperLimit(cMap.getUpperLimit());
            setLowerLimit(cMap.getLowerLimit());
        }


        //2. copy transparency, colormap name.
        setColorMapName(cMap.getCurrentColorMapName());
        setAlpha(cMap.getAlpha());

        setInverted(cMap.getInverted());
    }

    /**
     * Get the available colormaps.
     *
     * @return name of all the available colormaps
     */
    public Object[] getColorMapNames() {
        return _colorMapNames;
    }

	/**
	 * Get colormap's name.
	 *
	 * @return Name of colormap.
	 *
	 * @uml.property name="_currentColorMapName"
	 */
	public Object getCurrentColorMapName() {
		return _currentColorMapName;
	}

	/**
	 *
	 * @uml.property name="_colorMap"
	 */
	//*****************************************************
	// Shin, Bae Cheol
	// 9/02/2004
	// TEST
	// TEST Begin
	public ColorMap getColorMapRule() {

		return _colorMap;
	}

	// TEST END
	//*****************************************************

	/**
	 * Set which colormap to use.
	 *
	 * @param colorMapName  Name of the colormap to be created.
	 *
	 * @uml.property name="_currentColorMapName"
	 */
	public void setColorMapName(Object colorMapName) {
		if (!colorMapName.equals(_currentColorMapName)) {
			byte alpha = 127;
			int lowerLimit = 0;
			int upperLimit = _size - 1;

			//first retrieve important parameters in last colormap
			if (_colorMap != null) {
				alpha = _colorMap.getAlpha();
				lowerLimit = _colorMap.getLowerLimit();
				upperLimit = _colorMap.getUpperLimit();
				//System.out.println(alpha);
				//System.out.println(upperLimit);
				//System.out.println(lowerLimit);
			}

			//load class if it is not used as current colormap
			try {
				//create an instance of this colormap with default settings
				Class colorMapClass = (Class) _colorMapClasses
					.get(colorMapName);
				//System.out.println("colorMapClass"+colorMapClass);
				//System.out.println("ColorMap Name"+colorMapName);
				_colorMap = (ColorMap) colorMapClass.newInstance();
				_colorMap.initializeColorMap(_size, _bits);

				//set the property of the colormap to be the same
				// as the previous colormap
				_colorMap.setAlpha(alpha);
				_colorMap.setLimits(lowerLimit, upperLimit);
				_colorMap.setInverted(_isInverted);

				//fire a notification if change successfully
				firePropertyChange(
					"ColorMapName",
					_currentColorMapName,
					colorMapName);

				_currentColorMapName = colorMapName;
			} catch (Exception e) {
				System.out.println("Error loading colormap plugin: "
					+ colorMapName);
				e.printStackTrace();
			}
		}
	}


    /**
     * Set under color
     */
    public void setUnderColor(Color underColor) {
        Color oldUnderColor = _colorMap.getUnderColor();

        _colorMap.setUnderColor(underColor);
        firePropertyChange("UnderColor", oldUnderColor,
        underColor);
    }


    /**
     * Get under color.
     */
    public Color getUnderColor() {
        return _colorMap.getUnderColor();
    }

	/**
	 * Set inverted.
	 *
	 * @uml.property name="_isInverted"
	 */
	public void setInverted(boolean flag) {
		_colorMap.setInverted(flag);
		firePropertyChange("Inverted", new Boolean(_isInverted), new Boolean(
			flag));
		_isInverted = flag;
	}


    /**
     * Get inverted.
     */
    public boolean getInverted() {
        return _colorMap.getInverted();
    }

    /**
     * Set over color
     */
    public void setOverColor(Color overColor) {
        Color oldOverColor = _colorMap.getOverColor();

        _colorMap.setOverColor(overColor);
        firePropertyChange("OverColor", oldOverColor,
        overColor);
    }


    /**
     * Get over color.
     */
    public Color getOverColor() {
        return _colorMap.getOverColor();
    }

    /**
     * set upper limit
     */
    public void setUpperLimit(int upperLimit) {
        int previousLimit = _colorMap.getUpperLimit();

        //System.out.println("BoundedColorMap::Using setUpperLimit Method");
        _colorMap.setUpperLimit(upperLimit);

        //System.out.println("BoundedColorMap::before firePropertyChange");


        firePropertyChange("UpperLimit", new Integer(previousLimit),
        new Integer(_colorMap.getUpperLimit()));

        //System.out.println("BoundedColorMap::after firePropertyChange");
    }

    /**
     * Get upper limit.
     */
    public int getUpperLimit() {
        return _colorMap.getUpperLimit();
    }

    /**
     * set lower limit
     */
    public void setLowerLimit(int lowerLimit) {
        int previousLimit = _colorMap.getLowerLimit();

        _colorMap.setLowerLimit(lowerLimit);
        firePropertyChange("LowerLimit", new Integer(previousLimit),
        new Integer(_colorMap.getLowerLimit()));
    }


    /**
     * Get lower limit.
     */
    public int getLowerLimit() {
        return _colorMap.getLowerLimit();
    }

    /**
     * set transparency.
     */
    public void setAlpha(byte alpha) {
        if(alpha!=_colorMap.getAlpha()) {
            Byte oldAlpha = new Byte(_colorMap.getAlpha());

            _colorMap.setAlpha(alpha);
            firePropertyChange("Alpha", oldAlpha,
            new Byte(alpha));
        }
    }

    /**
     * Get transparency.
     */
    public byte getAlpha() {
        return _colorMap.getAlpha();
    }

    /**
     * Get a colormodel of current colormap.
     */
    public ColorModel getColorModel() {
        return _colorMap.getColorModel();
    }

    /**
     * Get Red map
     */
    public byte[] getRedMap() {
        return _colorMap.getRedMap();
    }

    /**
     * Get Green map
     */
    public byte[] getGreenMap() {
        return _colorMap.getGreenMap();
    }


    /**
     * Get Blue map
     */
    public byte[] getBlueMap() {
        return _colorMap.getBlueMap();
    }

    /**
     * Get Alpha map
     */
    public byte[] getAlphaMap() {
        return _colorMap.getAlphaMap();
    }

    /**
     * Test Program
     */
    public static void main(String args[]) {
        BoundedColorMap map = new BoundedColorMap(256, 8);
        Enumeration e = _colorMapClasses.keys();
        for(;e.hasMoreElements();) {
            System.out.println(e.nextElement());
        }
    }


}
